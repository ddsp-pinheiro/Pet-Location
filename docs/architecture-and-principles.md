## üèõÔ∏è **Arquitetura**

A aplica√ß√£o segue a **Clean Architecture**, com as seguintes camadas:

1. **Camada de Apresenta√ß√£o**:
    - Exp√µe os endpoints da API.
    - Respons√°vel por receber requisi√ß√µes HTTP e retornar respostas.

2. **Camada de Aplica√ß√£o**:
    - Orquestra os casos de uso.

3. **Camada de Dom√≠nio**:
    - Cont√©m as entidades e regras de neg√≥cio.

4. **Camada de Infraestrutura**:
    - Lida com detalhes externos, como banco de dados e APIs externas.

---

## üß† **Abstra√ß√£o, Acoplamento, Extensibilidade e Coes√£o**

### **Abstra√ß√£o**
- Uso de interfaces para esconder detalhes de implementa√ß√£o.

### **Baixo Acoplamento**
- Inje√ß√£o de depend√™ncia e uso de interfaces.

### **Extensibilidade**
- Facilidade de adicionar novas funcionalidades.

### **Alta Coes√£o**
- Cada classe e m√©todo tem uma responsabilidade clara.

---

## üõ†Ô∏è **Design Patterns**

A aplica√ß√£o utiliza os seguintes padr√µes de projeto:

1. **Repository Pattern**:
    - `PetRepository` e `LocationRepository` para acesso ao banco de dados.

2. **Adapter Pattern**:
    - `PositionStackClient` adapta a API externa para o dom√≠nio da aplica√ß√£o.

3. **Singleton Pattern**:
    - Beans gerenciados pelo Spring (`@Service`, `@Repository`).

4. **Strategy Pattern**:
    - Tratamento de erros com `PositionStackError` e `GlobalExceptionHandler`.

5. **Observer Pattern**:
    - Atualiza√ß√£o de m√©tricas (`PetLocationMetrics`).

---

## üßπ **Clean Architecture**

A aplica√ß√£o adere aos princ√≠pios da **Clean Architecture**:
- **Testabilidade**: Facilita a cria√ß√£o de testes unit√°rios e de integra√ß√£o.
- **Manutenibilidade**: Mudan√ßas em uma camada n√£o afetam as outras.

---

## ‚ú® **Clean Code**

O c√≥digo da aplica√ß√£o segue boas pr√°ticas de **Clean Code**:
- Nomes Significativos
- Fun√ß√µes Pequenas e Espec√≠ficas**: 
- C√≥digo autoexplicativo.
---

## üîß **SOLID**

A aplica√ß√£o segue os princ√≠pios **SOLID**:

1. **Single Responsibility Principle (SRP)**:
    - Cada classe tem uma √∫nica responsabilidade.
    - `PetLocationService` gerencia localiza√ß√µes, `PetRepository` lida com persist√™ncia.

2. **Open/Closed Principle (OCP)**:
    - A aplica√ß√£o √© aberta para extens√£o e fechada para modifica√ß√£o.
    - Adicionar novos provedores de geolocaliza√ß√£o sem modificar o n√∫cleo.

3. **Liskov Substitution Principle (LSP)**:
    - Abstra√ß√µes podem ser substitu√≠das por implementa√ß√µes concretas.
    - `PetRepository` pode ser substitu√≠do por qualquer implementa√ß√£o.

4. **Interface Segregation Principle (ISP)**:
    - Interfaces s√£o espec√≠ficas e n√£o "gordas".
    - `PositionStackClient` cont√©m apenas m√©todos relacionados √† API externa.

5. **Dependency Inversion Principle (DIP)**:
    - M√≥dulos de alto n√≠vel dependem de abstra√ß√µes, n√£o de implementa√ß√µes concretas.
    - `PetLocationService` depende de `PetRepository` e `PositionStackClient`.

---

## üîç **Observabilidade**

A aplica√ß√£o foi projetada com foco em **observabilidade**:

1. **M√©tricas**:
    - `PetLocationMetrics` com Micrometer para monitorar registros de localiza√ß√£o.

2. **Logs**:
    - Logs detalhados em pontos-chave (in√≠cio e fim do registro de localiza√ß√£o, erros na API externa).

3. **Traces**:
    - Estrutura pronta para integra√ß√£o com ferramentas como Jaeger ou Zipkin.


